{"version":3,"sources":["directive_parser.js","@traceur/generated/TemplateParser/8","@traceur/generated/TemplateParser/25","@traceur/generated/TemplateParser/10"],"names":[],"mappings":"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","file":"/Users/patrick/Documents/open source/angular/modules/angular2/src/core/compiler/pipeline/directive_parser.js","sourceRoot":"/Users/patrick/Documents/open source/angular/modules/angular2/src/core/compiler/pipeline/","sourcesContent":["import {isPresent, isBlank, BaseException, assertionsEnabled, RegExpWrapper} from 'angular2/src/facade/lang';\nimport {List, MapWrapper, StringMapWrapper} from 'angular2/src/facade/collection';\nimport {DOM} from 'angular2/src/facade/dom';\nimport {SelectorMatcher} from '../selector';\nimport {CssSelector} from '../selector';\n\nimport {DirectiveMetadata} from '../directive_metadata';\nimport {Component, Viewport} from '../../annotations/annotations';\nimport {CompileStep} from './compile_step';\nimport {CompileElement} from './compile_element';\nimport {CompileControl} from './compile_control';\n\nimport {isSpecialProperty} from './element_binder_builder';;\n\nvar PROPERTY_BINDING_REGEXP = RegExpWrapper.create('^ *([^\\\\s\\\\|]+)');\n\n/**\n * Parses the directives on a single element. Assumes ViewSplitter has already created\n * <template> elements for template directives.\n *\n * Fills:\n * - CompileElement#decoratorDirectives\n * - CompileElement#templateDirecitve\n * - CompileElement#componentDirective.\n *\n * Reads:\n * - CompileElement#propertyBindings (to find directives contained\n *   in the property bindings)\n * - CompileElement#variableBindings (to find directives contained\n *   in the variable bindings)\n */\nexport class DirectiveParser extends CompileStep {\n  _selectorMatcher:SelectorMatcher;\n  constructor(directives:List<DirectiveMetadata>) {\n    super();\n    var selector;\n\n    this._selectorMatcher = new SelectorMatcher();\n    for (var i=0; i<directives.length; i++) {\n      var directiveMetadata = directives[i];\n      selector=CssSelector.parse(directiveMetadata.annotation.selector);\n      this._selectorMatcher.addSelectable(selector, directiveMetadata);\n    }\n  }\n\n  process(parent:CompileElement, current:CompileElement, control:CompileControl) {\n    var attrs = current.attrs();\n    var classList = current.classList();\n\n    var cssSelector = new CssSelector();\n    cssSelector.setElement(DOM.nodeName(current.element));\n    for (var i=0; i < classList.length; i++) {\n      cssSelector.addClassName(classList[i]);\n    }\n    MapWrapper.forEach(attrs, (attrValue, attrName) => {\n      if (isBlank(current.propertyBindings) ||\n        isPresent(current.propertyBindings) && !MapWrapper.contains(current.propertyBindings, attrName)) {\n        cssSelector.addAttribute(attrName, attrValue);\n      }\n    });\n    if (isPresent(current.propertyBindings)) {\n      MapWrapper.forEach(current.propertyBindings, (expression, prop) => {\n        cssSelector.addAttribute(prop, expression.source);\n      });\n    }\n    if (isPresent(current.variableBindings)) {\n      MapWrapper.forEach(current.variableBindings, (value, name) => {\n        cssSelector.addAttribute(name, value);\n      });\n    }\n    // Note: We assume that the ViewSplitter already did its work, i.e. template directive should\n    // only be present on <template> elements any more!\n    var isTemplateElement = DOM.isTemplateElement(current.element);\n    var matchedProperties; // StringMap - used in dev mode to store all properties that have been matched\n    \n    this._selectorMatcher.match(cssSelector, (selector, directive) => {\n      matchedProperties = updateMatchedProperties(matchedProperties, selector, directive);\n      checkDirectiveValidity(directive, current, isTemplateElement);\n      current.addDirective(directive);\n    });\n\n    // raise error if some directives are missing\n    checkMissingDirectives(current, matchedProperties, isTemplateElement);\n  }\n}\n\n// calculate all the properties that are used or interpreted by all directives\n// those properties correspond to the directive selectors and the directive bindings\nfunction updateMatchedProperties(matchedProperties, selector, directive) {\n  if (assertionsEnabled()) {\n    var attrs = selector.attrs;\n    if (!isPresent(matchedProperties)) {\n      matchedProperties = StringMapWrapper.create();\n    }\n    if (isPresent(attrs)) {\n      for (var idx = 0; idx<attrs.length; idx+=2) {\n        // attribute name is stored on even indexes\n        StringMapWrapper.set(matchedProperties, attrs[idx], true);\n      }\n    }\n    // some properties can be used by the directive, so we need to register them\n    if (isPresent(directive.annotation) && isPresent(directive.annotation.bind)) {\n      var bindMap = directive.annotation.bind;\n      StringMapWrapper.forEach(bindMap, (value, key) => {\n        // value is the name of the property that is intepreted\n        // e.g. 'myprop' or 'myprop | double' when a pipe is used to transform the property\n\n        // keep the property name and remove the pipe\n        var bindProp = RegExpWrapper.firstMatch(PROPERTY_BINDING_REGEXP, value);\n        if (isPresent(bindProp) && isPresent(bindProp[1])) {\n          StringMapWrapper.set(matchedProperties, bindProp[1], true);\n        }\n      });\n    }\n  }\n  return matchedProperties;\n}\n\n// check if the directive is compatible with the current element\nfunction checkDirectiveValidity(directive, current, isTemplateElement) {\n  if (directive.annotation instanceof Viewport) {\n    if (!isTemplateElement) {\n      throw new BaseException(`Viewport directives need to be placed on <template> elements or elements ` +\n         `with template attribute - check ${current.elementDescription}`);\n    } else if (isPresent(current.viewportDirective)) {\n      throw new BaseException(`Only one viewport directive can be used per element - check ${current.elementDescription}`);\n    }\n  } else if (isTemplateElement) {\n    throw new BaseException(`Only template directives are allowed on template elements - check ${current.elementDescription}`);\n  } else if ((directive.annotation instanceof Component) && isPresent(current.componentDirective)) {\n    throw new BaseException(`Multiple component directives not allowed on the same element - check ${current.elementDescription}`);\n  }\n}\n\n// validates that there is no missing directive - dev mode only\nfunction checkMissingDirectives(current, matchedProperties, isTemplateElement) {\n  if (assertionsEnabled()) {\n    var ppBindings=current.propertyBindings;\n    if (isPresent(ppBindings)) {\n      // check that each property corresponds to a real property or has been matched by a directive\n      MapWrapper.forEach(ppBindings, (expression, prop) => {\n        if (!DOM.hasProperty(current.element, prop) && !isSpecialProperty(prop)) {\n          if (!isPresent(matchedProperties) || !isPresent(StringMapWrapper.get(matchedProperties, prop))) {\n            throw new BaseException(`Missing directive to handle '${prop}' in ${current.elementDescription}`);\n          } \n        }\n      });\n    }\n    // template only store directives as attribute when they are not bound to expressions\n    // so we have to validate the expression case too (e.g. !if=\"condition\")\n    if (isTemplateElement && !current.isViewRoot && !isPresent(current.viewportDirective)) {\n      throw new BaseException(`Missing directive to handle: ${current.elementDescription}`);\n    }\n  }\n}\n","assert.argumentTypes($__placeholder__0)","assert.genericType($__placeholder__0)","Object.defineProperty($__placeholder__0, $__placeholder__1,\n        {get: function() {return $__placeholder__2}});"]}